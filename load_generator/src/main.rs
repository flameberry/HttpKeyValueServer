use std::thread::JoinHandle;
use std::time::{Duration, SystemTime};

use reqwest::Client as NonBlockingClient;
use reqwest::blocking::Client as BlockingClient;
use serde::Serialize;
use uuid::Uuid;

const BASE_URL: &str = "http://127.0.0.1:3000/kv";

#[derive(Serialize)]
struct PutPayload {
    value: String,
}

async fn populate_keys(num_keys: u32) -> Vec<String> {
    let client = NonBlockingClient::new();
    let mut keys: Vec<String> = Vec::new();

    for _ in 0..num_keys {
        let uuid: String = Uuid::new_v4().to_string();

        let payload = PutPayload {
            value: format!("Value generated by `populate_keys` for the key: {}", uuid),
        };

        match client.put(format!("{}/{}", BASE_URL, uuid)).json(&payload).send().await {
            Ok(response) => {
                println!("Response Status: {}", response.status());
                keys.push(uuid);
            }
            Err(err) => eprintln!("Request Failed: {}", err),
        }
    }
    keys
}

fn workload_put(num_clients: usize, duration: Duration) {
    let start = SystemTime::now();
    let handles: Vec<JoinHandle<()>> = vec![(); num_clients]
        .iter()
        .map(|_| {
            std::thread::spawn(move || {
                let client = BlockingClient::new();

                loop {
                    let uuid: String = Uuid::new_v4().to_string();

                    let payload = PutPayload {
                        value: format!("Value generated by `workload_put` for the key: {}", uuid),
                    };

                    match client.put(format!("{}/{}", BASE_URL, uuid)).json(&payload).send() {
                        Ok(response) => println!("Response Status: {}", response.status()),
                        Err(err) => eprintln!("Request Failed: {}", err),
                    }

                    match start.elapsed() {
                        Ok(elapsed) if elapsed > duration => {
                            return;
                        }
                        _ => (),
                    }
                }
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap();
    }
}

fn workload_get() {}

fn workload_mixed() {}

fn workload_custom() {
    println!("Welcome to the load generator");

    const NUM_THREADS: usize = 10;
    const NUM_REQUESTS_PER_THREAD: usize = 10000;

    let handles: [std::thread::JoinHandle<usize>; NUM_THREADS] = [(); NUM_THREADS].map(|_| {
        std::thread::spawn(move || {
            let client = BlockingClient::new();
            let mut num_errors = 0;

            for _ in 0..NUM_REQUESTS_PER_THREAD {
                let key = "Aditya";
                match client.get(format!("{}/{}", BASE_URL, key)).send() {
                    Ok(response) => {
                        let text = response.text().unwrap();
                        println!("Response: {}", text);
                    }
                    Err(err) => {
                        eprintln!("{}", err);
                        num_errors += 1;
                    }
                }
            }
            return num_errors;
        })
    });

    let mut num_errors = 0;
    for handle in handles {
        num_errors += handle.join().unwrap();
    }
    println!(
        "Total errors: {}/{} i.e. {} %",
        num_errors,
        NUM_THREADS * NUM_REQUESTS_PER_THREAD,
        100.0 * num_errors as f32 / (NUM_THREADS * NUM_REQUESTS_PER_THREAD) as f32
    );
}

fn main() {
    workload_put(5, Duration::from_secs(10));
}
